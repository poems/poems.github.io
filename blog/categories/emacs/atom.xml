<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Emacs | My Octopress Blog]]></title>
  <link href="http://poems.github.io/blog/categories/emacs/atom.xml" rel="self"/>
  <link href="http://poems.github.io/"/>
  <updated>2013-11-23T17:43:39+00:00</updated>
  <id>http://poems.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[macro &amp; defmacro in Emacs]]></title>
    <link href="http://poems.github.io/blog/2013/11/23/macro-and-defmacro-in-emacs/"/>
    <updated>2013-11-23T16:42:00+00:00</updated>
    <id>http://poems.github.io/blog/2013/11/23/macro-and-defmacro-in-emacs</id>
    <content type="html"><![CDATA[<p>学习下Lisp的宏（macro）。</p>

<p>首先，区别：Lisp宏和键盘宏（keyboard macro）是两个不同的概念。</p>

<p>一个LISP宏(Lisp Macro)是一个扩展LISP语言的用户定义的结构.
 宏不像函数那样对参数执行表达式. 它们只是在构造一个包括这些参数的表达式.</p>

<blockquote><p>也就是，宏是一个结构，是在构造。就是Lisp非常牛逼的一点：Code as data。</p></blockquote>

<p>首先看下语法定义：</p>

<p><code>defmacro</code> is a Lisp macro in `byte-run.el'.</p>

<p><code>
(defmacro NAME ARGLIST &amp;optional DOCSTRING DECL &amp;rest BODY)
</code></p>

<p>Define NAME as a macro.
When the macro is called, as in (NAME ARGS&hellip;),
the function (lambda ARGLIST BODY&hellip;) is applied to
the list ARGS&hellip; as it appears in the expression,
and the result should be a form to be evaluated instead of the original.
DECL is a declaration, optional, of the form (declare DECLS&hellip;) where
DECLS is a list of elements of the form (PROP . VALUES).  These are
interpreted according to `macro-declarations-alist'.
The return value is undefined.</p>

<p>好长的解释。</p>

<p>看一个实例：</p>

<p>```
(defmacro inc (var)
  (list &lsquo;setq var (list '1+ var)))</p>

<p>```</p>

<blockquote><p>注意一点：<code>(list '1+ var)</code> 开始时写成<code>(list '1+var)</code>，少写了一个空格。</p></blockquote>

<p>定义了一个Lisp宏：<code>inc (var)</code>。这个macro的BODY是（按照list函数拼出来）:</p>

<p><code>
(setq var (1+ var))
</code></p>

<p>当然也可以这样展开宏：</p>

<p><code>
(macroexpand '(inc x))
</code></p>

<p>现在就可以用宏了：</p>

<p><code>
(setq x 1)
(inc x)
</code></p>

<blockquote><p>解释:</p></blockquote>

<p><code>list</code> 的用法</p>

<p><code>``
list is a built-in function in</code>C source code'.</p>

<p>(list &amp;rest OBJECTS)</p>

<p>Return a newly created list with specified arguments as elements.
Any number of arguments, even zero arguments, are allowed.</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Growing Emacser]]></title>
    <link href="http://poems.github.io/blog/2013/11/23/a-growing-emacser/"/>
    <updated>2013-11-23T16:00:00+00:00</updated>
    <id>http://poems.github.io/blog/2013/11/23/a-growing-emacser</id>
    <content type="html"><![CDATA[<hr />

<p><code>when:</code> when is a lisp macro</p>

<p><code>
(when COND BODY...)
</code>
If COND yields non-nil, do BODY, else return nil.
When COND yields non-nil, eval BODY forms sequentially and return
value of last one, or nil if there are none.</p>

<hr />

<p><code>fboundp</code> is a built-in function in `C source code'.</p>

<p><code>
(fboundp SYMBOL)
</code></p>

<hr />

<p><code>add-to-list</code> is a compiled Lisp function in `subr.el'.</p>

<p><code>
(add-to-list LIST-VAR ELEMENT &amp;optional APPEND COMPARE-FN)
</code></p>

<p>Add ELEMENT to the value of <code>LIST-VAR</code> if it isn&rsquo;t there yet.
The test for presence of <code>ELEMENT</code> is done with <code>equal</code>,
or with <code>COMPARE-FN</code> if that&rsquo;s non-nil.
If <code>ELEMENT</code> is added, it is added at the beginning of the list,
unless the optional argument <code>APPEND</code> is non-nil, in which case
ELEMENT is added at the end.</p>

<p>The return value is the new value of LIST-VAR.</p>

<hr />

<p><code>provide</code> is a built-in function in `C source code'.</p>

<p><code>
(provide FEATURE &amp;optional SUBFEATURES)
</code></p>

<p>Announce that FEATURE is a feature of the current Emacs.
The optional argument SUBFEATURES should be a list of symbols listing
particular subfeatures supported in this version of FEATURE.</p>

<hr />

<p><code>C-x h</code> runs the command mark-whole-buffer</p>

<p><code>C-w</code> runs the command kill region</p>

<hr />

<p>use <code>C-x &lt;right&gt;</code>, <code>C-x &lt;left&gt;</code> to cycle around in the buffer ring.</p>

<p><code>iswitchb-mode</code> replaces the default C-x b behaviour with a very intuitive buffer-switching-with-completion system.</p>

<p>The related commands are <code>C-x b</code>, <code>C-s</code> and <code>C-r</code>.</p>

<hr />
]]></content>
  </entry>
  
</feed>

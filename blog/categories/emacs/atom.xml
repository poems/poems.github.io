<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Emacs | My Octopress Blog]]></title>
  <link href="http://poems.github.io/blog/categories/emacs/atom.xml" rel="self"/>
  <link href="http://poems.github.io/"/>
  <updated>2013-11-27T23:30:54+00:00</updated>
  <id>http://poems.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ease Life with YASnippet]]></title>
    <link href="http://poems.github.io/blog/2013/11/24/ease-life-with-yasnippet/"/>
    <updated>2013-11-24T01:44:00+00:00</updated>
    <id>http://poems.github.io/blog/2013/11/24/ease-life-with-yasnippet</id>
    <content type="html"><![CDATA[<p>安装使用<code>package-install</code>，实际上可以写一个简易方法避免重复劳动：</p>

<p>```
(defun require-package (package)
  &ldquo;Install given PACKAGE.&rdquo;
  (unless (package-installed-p package)</p>

<pre><code>(unless (assoc package package-archive-contents)
  (package-refresh-contents))
(package-install package)))
</code></pre>

<p>```</p>

<blockquote><p>学习下其中的1个function</p>

<p><code>assoc</code> is a built-in function in `C source code'.</p>

<p><code>
(assoc KEY LIST)
</code></p>

<p>Return non-nil if KEY is `equal' to the car of an element of LIST.
The value is actually the first element of LIST whose car equals KEY.</p></blockquote>

<p>开始学习如何使用YASnippet。</p>

<p><strong>1 组织你的 Snippets</strong> (<em>Organizing Snippets</em>)</p>

<p>Snippet的定义是储存在文件系统的文件中。YASnippet的触发机制会找到这些snippet tables，然后展开。</p>

<p>首先，新建一个目录：my-snippets，用来存放自定义的snippets。</p>

<p>```
(require &lsquo;yasnippet)</p>

<p>(setq yas-snippet-dirs (concat user-emacs-directory &ldquo;my-snippets&rdquo;))</p>

<p>(add-hook &lsquo;prog-mode-hook 'yas-minor-mode)
```</p>

<p>看下是怎么组织snippets的（这是YASnippet自带的）：</p>

<p>```
snippets tree -a . | head -n 20                                                                                                                      system
.
├── c++-mode
│   ├── .yas-parents
│   ├── beginend
│   ├── class
│   ├── ns
│   ├── template
│   └── using
├── c-mode
│   ├── .yas-parents
│   ├── fopen
│   └── printf
├── cc-mode
│   ├── .yas-parents
│   ├── do
│   ├── for
│   ├── if
│   ├── inc
│   ├── inc.1
│   ├── main</p>

<p>```</p>

<p><code>.yas.parent</code>文件可以共享其他目录下的snippets。</p>

<p>如果有一个空的<code>.yas-make-groups</code>文件，会在 YASnippet Menu按照目录结构组织地更清晰。</p>

<p><strong>2 展开你的 Snippets</strong> (<em>Traiggering expansion</em>)</p>

<p>很多中方式能展开snippets，包括：</p>

<ul>
<li><p>By typing an abbrev, the snippet trigger key, and then pressing the key defined in yas/trigger-key (which defaults to &ldquo;TAB&rdquo;). This works in buffers where the minor mode yas/minor-mode is active;</p></li>
<li><p>By invoking the command yas/insert-snippet (either by typing M-x yas/insert-snippet or its keybinding). This does not require yas/minor-mode to be active.</p></li>
<li><p>By using hippie-expand</p></li>
</ul>


<p>以上是3中最常见的方法（虽然我不知道什么是 hippie-expand）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[macro &amp; defmacro in Emacs]]></title>
    <link href="http://poems.github.io/blog/2013/11/23/macro-and-defmacro-in-emacs/"/>
    <updated>2013-11-23T16:42:00+00:00</updated>
    <id>http://poems.github.io/blog/2013/11/23/macro-and-defmacro-in-emacs</id>
    <content type="html"><![CDATA[<p>学习下Lisp的宏（macro）。</p>

<p>首先，区别：Lisp宏和键盘宏（keyboard macro）是两个不同的概念。</p>

<p>一个LISP宏(Lisp Macro)是一个扩展LISP语言的用户定义的结构.
 宏不像函数那样对参数执行表达式. 它们只是在构造一个包括这些参数的表达式.</p>

<blockquote><p>也就是，宏是一个结构，是在构造。就是Lisp非常牛逼的一点：Code as data。</p></blockquote>

<p>首先看下语法定义：</p>

<p><code>defmacro</code> is a Lisp macro in `byte-run.el'.</p>

<p><code>
(defmacro NAME ARGLIST &amp;optional DOCSTRING DECL &amp;rest BODY)
</code></p>

<p>Define NAME as a macro.
When the macro is called, as in (NAME ARGS&hellip;),
the function (lambda ARGLIST BODY&hellip;) is applied to
the list ARGS&hellip; as it appears in the expression,
and the result should be a form to be evaluated instead of the original.
DECL is a declaration, optional, of the form (declare DECLS&hellip;) where
DECLS is a list of elements of the form (PROP . VALUES).  These are
interpreted according to `macro-declarations-alist'.
The return value is undefined.</p>

<p>好长的解释。</p>

<p>看一个实例：</p>

<p>```
(defmacro inc (var)
  (list &lsquo;setq var (list '1+ var)))</p>

<p>```</p>

<blockquote><p>注意一点：<code>(list '1+ var)</code> 开始时写成<code>(list '1+var)</code>，少写了一个空格。</p></blockquote>

<p>定义了一个Lisp宏：<code>inc (var)</code>。这个macro的BODY是（按照list函数拼出来）:</p>

<p><code>
(setq var (1+ var))
</code></p>

<p>当然也可以这样展开宏：</p>

<p><code>
(macroexpand '(inc x))
</code></p>

<p>现在就可以用宏了：</p>

<p><code>
(setq x 1)
(inc x)
</code></p>

<blockquote><p>解释:</p></blockquote>

<p><code>list</code> 的用法</p>

<p><code>``
list is a built-in function in</code>C source code'.</p>

<p>(list &amp;rest OBJECTS)</p>

<p>Return a newly created list with specified arguments as elements.
Any number of arguments, even zero arguments, are allowed.</p>

<p>```</p>

<p>宏还有一种写法，就是使用反引用（Backquote）。</p>

<p>我们可以用 &lsquo; 引用一个对象并不执行.我们还可以用 反引用 ` 引用一个列表, 但是只是选择性的执行列表的元素.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Growing Emacser]]></title>
    <link href="http://poems.github.io/blog/2013/11/23/a-growing-emacser/"/>
    <updated>2013-11-23T16:00:00+00:00</updated>
    <id>http://poems.github.io/blog/2013/11/23/a-growing-emacser</id>
    <content type="html"><![CDATA[<hr />

<p><code>when:</code> when is a lisp macro</p>

<p><code>
(when COND BODY...)
</code>
If COND yields non-nil, do BODY, else return nil.
When COND yields non-nil, eval BODY forms sequentially and return
value of last one, or nil if there are none.</p>

<hr />

<p><code>fboundp</code> is a built-in function in `C source code'.</p>

<p><code>
(fboundp SYMBOL)
</code></p>

<hr />

<p><code>add-to-list</code> is a compiled Lisp function in `subr.el'.</p>

<p><code>
(add-to-list LIST-VAR ELEMENT &amp;optional APPEND COMPARE-FN)
</code></p>

<p>Add ELEMENT to the value of <code>LIST-VAR</code> if it isn&rsquo;t there yet.
The test for presence of <code>ELEMENT</code> is done with <code>equal</code>,
or with <code>COMPARE-FN</code> if that&rsquo;s non-nil.
If <code>ELEMENT</code> is added, it is added at the beginning of the list,
unless the optional argument <code>APPEND</code> is non-nil, in which case
ELEMENT is added at the end.</p>

<p>The return value is the new value of LIST-VAR.</p>

<hr />

<p><code>provide</code> is a built-in function in `C source code'.</p>

<p><code>
(provide FEATURE &amp;optional SUBFEATURES)
</code></p>

<p>Announce that FEATURE is a feature of the current Emacs.
The optional argument SUBFEATURES should be a list of symbols listing
particular subfeatures supported in this version of FEATURE.</p>

<hr />

<p><code>C-x h</code> runs the command mark-whole-buffer</p>

<p><code>C-w</code> runs the command kill region</p>

<hr />

<p>use <code>C-x &lt;right&gt;</code>, <code>C-x &lt;left&gt;</code> to cycle around in the buffer ring.</p>

<p><code>iswitchb-mode</code> replaces the default C-x b behaviour with a very intuitive buffer-switching-with-completion system.</p>

<p>The related commands are <code>C-x b</code>, <code>C-s</code> and <code>C-r</code>.</p>

<hr />

<p>emacs <code>dired</code> mode.</p>

<p><code>C-x C-j</code>: (dired-jump to current file)
<code>R</code> to rename the file (or &lsquo;dired-do-rename&rsquo;).
<code>C-x k RET</code> to go back to the (renamed) buffer</p>

<hr />
]]></content>
  </entry>
  
</feed>
